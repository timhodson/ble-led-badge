"""
Text rendering for LED badge displays.

Converts text strings to bitmap data suitable for upload to the badge.
Uses a 9-row font (8 pixels wide, 9 pixels tall per character).

Supports multi-width characters where a single character can span multiple
standard character widths (each segment is 9 bytes).

Font data format:
- Single-width: [b0, b1, ..., b8] (9 integers)
- Multi-width: [[b0...b8], [b0...b8], ...] (array of 9-byte arrays)
"""

import json
from pathlib import Path
from typing import List, Union


class TextRenderer:
    """Render text to bitmap for LED badge display."""

    # 9-byte column-based font extracted from iPhone app trace analysis
    # Each character is 9 bytes (one byte per column, 8 pixels tall)
    # Byte values represent vertical columns, bit 0 at top
    # Font data extracted from traces/alphabet-trace.btsnoop
    FONT = {
        # Uppercase letters (extracted from alphabet trace)
        'A': [0x00, 0x4c, 0x07, 0x39, 0x00, 0x0f, 0x01, 0xc4, 0x00],
        'B': [0x20, 0x4c, 0x3f, 0x24, 0x44, 0x24, 0x1b, 0x80, 0x00],
        'C': [0x1f, 0x84, 0x20, 0x20, 0x44, 0x20, 0x30, 0x80, 0x00],
        'D': [0x20, 0x4c, 0x3f, 0x20, 0x44, 0x20, 0x1f, 0x80, 0x00],
        'E': [0x20, 0x4c, 0x3f, 0x24, 0x44, 0x2e, 0x30, 0xc0, 0x00],
        'F': [0x20, 0x4c, 0x3f, 0x24, 0x40, 0x2e, 0x30, 0x00, 0x00],
        'G': [0x0f, 0x08, 0x10, 0x20, 0x44, 0x22, 0x33, 0x80, 0x02],
        'H': [0x20, 0x4c, 0x3f, 0x04, 0x00, 0x04, 0x3f, 0xc4, 0x20],
        'I': [0x20, 0x44, 0x20, 0x3f, 0xc4, 0x20, 0x20, 0x40, 0x00],
        'J': [0x00, 0x62, 0x20, 0x20, 0x2c, 0x3f, 0x20, 0x00, 0x20],
        'K': [0x20, 0x4c, 0x3f, 0x24, 0x40, 0x0b, 0x30, 0xc4, 0x20],
        'L': [0x20, 0x4c, 0x3f, 0x20, 0x44, 0x00, 0x00, 0x4c, 0x00],
        'M': [0x3f, 0xc0, 0x3c, 0x03, 0xc0, 0x3c, 0x3f, 0xc0, 0x00],
        'N': [0x20, 0x4c, 0x3f, 0x0c, 0x40, 0x23, 0x3f, 0xc0, 0x20],
        'O': [0x1f, 0x84, 0x20, 0x20, 0x44, 0x20, 0x1f, 0x80, 0x00],
        'P': [0x20, 0x4c, 0x3f, 0x24, 0x40, 0x24, 0x18, 0x00, 0x00],
        'Q': [0x1f, 0x84, 0x21, 0x21, 0x4e, 0x20, 0x1f, 0xa0, 0x00],
        'R': [0x20, 0x4c, 0x3f, 0x24, 0x40, 0x26, 0x19, 0xc4, 0x00],
        'S': [0x18, 0xc4, 0x24, 0x24, 0x44, 0x22, 0x31, 0x80, 0x00],
        'T': [0x30, 0x04, 0x20, 0x3f, 0xc4, 0x20, 0x30, 0x00, 0x00],
        'U': [0x20, 0x08, 0x3f, 0x00, 0x44, 0x00, 0x3f, 0x80, 0x20],
        'V': [0x20, 0x00, 0x3e, 0x01, 0xc0, 0x07, 0x38, 0x00, 0x20],
        'W': [0x38, 0x0c, 0x07, 0x3c, 0x0c, 0x07, 0x38, 0x00, 0x00],
        'X': [0x20, 0x4c, 0x39, 0x06, 0x0c, 0x39, 0x20, 0x40, 0x00],
        'Y': [0x20, 0x04, 0x38, 0x07, 0xc4, 0x38, 0x20, 0x00, 0x00],
        'Z': [0x30, 0x4c, 0x21, 0x26, 0x44, 0x38, 0x20, 0xc0, 0x00],

        # Lowercase letters (extracted from alphabet trace)
        'a': [0x00, 0x08, 0x02, 0x05, 0x44, 0x05, 0x03, 0xc4, 0x00],
        'b': [0x20, 0x0c, 0x3f, 0x04, 0x44, 0x04, 0x03, 0x80, 0x00],
        'c': [0x00, 0x08, 0x03, 0x04, 0x44, 0x04, 0x06, 0x40, 0x00],
        'd': [0x00, 0x08, 0x03, 0x04, 0x44, 0x24, 0x3f, 0xc4, 0x00],
        'e': [0x00, 0x08, 0x03, 0x05, 0x44, 0x05, 0x03, 0x40, 0x00],
        'f': [0x00, 0x04, 0x04, 0x1f, 0xc4, 0x24, 0x24, 0x40, 0x20],
        'g': [0x00, 0x0e, 0x02, 0x05, 0x55, 0x05, 0x06, 0x52, 0x04],
        'h': [0x20, 0x4c, 0x3f, 0x04, 0x40, 0x04, 0x03, 0xc4, 0x00],
        'i': [0x00, 0x04, 0x04, 0x27, 0xc4, 0x00, 0x00, 0x00, 0x00],
        'j': [0x00, 0x11, 0x00, 0x04, 0x1e, 0x27, 0x00, 0x00, 0x00],
        'k': [0x20, 0x4c, 0x3f, 0x01, 0x40, 0x07, 0x04, 0xc4, 0x04],
        'l': [0x20, 0x44, 0x20, 0x3f, 0xc4, 0x00, 0x00, 0x40, 0x00],
        'm': [0x07, 0xc0, 0x04, 0x07, 0xc0, 0x04, 0x03, 0xc0, 0x00],
        'n': [0x04, 0x4c, 0x07, 0x04, 0x40, 0x04, 0x03, 0xc4, 0x00],
        'o': [0x00, 0x08, 0x03, 0x04, 0x44, 0x04, 0x03, 0x80, 0x00],
        'p': [0x04, 0x1f, 0x07, 0x04, 0x54, 0x04, 0x03, 0x80, 0x00],
        'q': [0x00, 0x08, 0x03, 0x04, 0x45, 0x04, 0x07, 0xf1, 0x00],
        'r': [0x04, 0x4c, 0x07, 0x02, 0x40, 0x04, 0x04, 0x00, 0x00],
        's': [0x00, 0x04, 0x06, 0x05, 0x44, 0x05, 0x04, 0xc0, 0x00],
        't': [0x00, 0x00, 0x04, 0x1f, 0x84, 0x04, 0x00, 0x40, 0x00],
        'u': [0x04, 0x08, 0x07, 0x00, 0x44, 0x04, 0x07, 0xc4, 0x00],
        'v': [0x04, 0x00, 0x07, 0x04, 0xc8, 0x01, 0x06, 0x00, 0x04],
        'w': [0x06, 0x0c, 0x01, 0x07, 0x0c, 0x01, 0x06, 0x00, 0x00],
        'x': [0x04, 0x4c, 0x06, 0x01, 0x0c, 0x06, 0x04, 0x40, 0x00],
        'y': [0x04, 0x11, 0x07, 0x04, 0xe8, 0x01, 0x06, 0x00, 0x04],
        'z': [0x00, 0x04, 0x04, 0x05, 0xc4, 0x06, 0x04, 0x40, 0x00],

        # Space
        ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],

        # Numbers (not in alphabet trace - keeping previous estimates)
        '0': [0x00, 0x08, 0x02, 0x24, 0x44, 0x24, 0x02, 0x08, 0x00],
        '1': [0x00, 0x00, 0x04, 0x42, 0x3f, 0xc4, 0x40, 0x00, 0x00],
        '2': [0x00, 0x00, 0x42, 0x61, 0x50, 0x48, 0x46, 0x00, 0x00],
        '3': [0x00, 0x00, 0x02, 0x44, 0x44, 0x24, 0x1a, 0x00, 0x00],
        '4': [0x00, 0x10, 0x18, 0x14, 0x12, 0x3f, 0xd0, 0x10, 0x00],
        '5': [0x00, 0x00, 0x0e, 0x45, 0x44, 0x44, 0x38, 0x00, 0x00],
        '6': [0x00, 0x08, 0x12, 0x24, 0x44, 0x24, 0x18, 0x00, 0x00],
        '7': [0x00, 0x00, 0x04, 0x64, 0x14, 0x0c, 0x04, 0x00, 0x00],
        '8': [0x00, 0x00, 0x1a, 0x24, 0x44, 0x24, 0x1a, 0x00, 0x00],
        '9': [0x00, 0x00, 0x06, 0x09, 0x44, 0x29, 0x12, 0x04, 0x00],

        # Punctuation (extracted from alphabet trace)
        ',': [0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '.': [0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '!': [0x00, 0x00, 0x00, 0x3f, 0x40, 0x00, 0x00, 0x00, 0x00],
        '?': [0x18, 0x00, 0x20, 0x23, 0x40, 0x24, 0x18, 0x00, 0x00],
        # Additional punctuation (keeping previous estimates)
        '-': [0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00],
        ':': [0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00],
        "'": [0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],
    }

    BYTES_PER_SEGMENT = 9
    ROWS_PER_CHAR = 9  # Legacy alias

    @staticmethod
    def is_multi_width(char_data: Union[List[int], List[List[int]]]) -> bool:
        """Check if character data represents a multi-width character."""
        return isinstance(char_data, list) and len(char_data) > 0 and isinstance(char_data[0], list)

    @staticmethod
    def get_char_width(char_data: Union[List[int], List[List[int]]]) -> int:
        """Get the width (number of segments) of a character."""
        if char_data is None:
            return 1
        if TextRenderer.is_multi_width(char_data):
            return len(char_data)
        return 1

    @staticmethod
    def get_segments(char_data: Union[List[int], List[List[int]]]) -> List[List[int]]:
        """Get all segments of a character as a list of 9-byte arrays."""
        if char_data is None:
            return [[0] * 9]
        if TextRenderer.is_multi_width(char_data):
            return char_data
        return [char_data]

    @classmethod
    def load_font_from_json(cls) -> bool:
        """
        Load font from JSON file if available.

        Looks for font.json in the font-editor directory relative to project root.

        Returns:
            True if font was loaded from JSON, False otherwise
        """
        # Try multiple potential locations for font.json
        json_paths = [
            Path(__file__).parent.parent / 'font-editor' / 'font.json',
            Path(__file__).parent / 'font.json',
        ]

        for json_path in json_paths:
            if json_path.exists():
                try:
                    with open(json_path, 'r') as f:
                        font_data = json.load(f)
                    # Update FONT dict with loaded data
                    cls.FONT.update(font_data)
                    return True
                except (json.JSONDecodeError, IOError):
                    continue

        return False

    @staticmethod
    def _reverse_bits(byte: int) -> int:
        """Reverse the bit order in a byte (mirror horizontally)."""
        result = 0
        for i in range(8):
            if byte & (1 << i):
                result |= (1 << (7 - i))
        return result

    @staticmethod
    def render_text(text: str) -> bytes:
        """
        Render text to bitmap data for the badge display.

        The badge display uses 9 bytes per character segment, where each byte
        represents a vertical column of 8 pixels. Data is organized
        character-by-character, with multi-width characters sending multiple
        9-byte segments in sequence.

        Args:
            text: Text string to render

        Returns:
            Bitmap data as bytes, suitable for upload to badge
        """
        result = bytearray()

        # Process each character - data is character-by-character
        for char in text:
            # Get character bitmap
            char_data = TextRenderer.FONT.get(char, TextRenderer.FONT.get(' ', [0] * 9))

            # Get all segments (handles both single and multi-width)
            segments = TextRenderer.get_segments(char_data)

            # Add all segments of this character
            for segment in segments:
                for col_byte in segment:
                    result.append(col_byte)

        return bytes(result)

    @staticmethod
    def get_text_width(text: str) -> int:
        """
        Get the width in pixels of the rendered text.

        Accounts for multi-width characters that span multiple standard widths.

        Args:
            text: Text to measure

        Returns:
            Width in pixels (8 pixels per character segment)
        """
        total_segments = 0
        for char in text:
            char_data = TextRenderer.FONT.get(char, TextRenderer.FONT.get(' ', [0] * 9))
            total_segments += TextRenderer.get_char_width(char_data)
        return total_segments * 8

    @staticmethod
    def get_data_length(text: str) -> int:
        """
        Get the total byte length of rendered text.

        Accounts for multi-width characters that use multiple 9-byte segments.

        Args:
            text: Text to measure

        Returns:
            Total bytes (9 bytes per character segment)
        """
        total_segments = 0
        for char in text:
            char_data = TextRenderer.FONT.get(char, TextRenderer.FONT.get(' ', [0] * 9))
            total_segments += TextRenderer.get_char_width(char_data)
        return total_segments * TextRenderer.BYTES_PER_SEGMENT


# Load font from JSON on module import (if available)
TextRenderer.load_font_from_json()
