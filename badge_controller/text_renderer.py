"""
Text rendering for LED badge displays.

Converts text strings to bitmap data suitable for upload to the badge.
Uses a 9-row font (8 pixels wide, 9 pixels tall per character).
"""

from typing import List


class TextRenderer:
    """Render text to bitmap for LED badge display."""

    # 9-byte column-based font extracted from iPhone app trace analysis
    # Each character is 9 bytes (one byte per column, 8 pixels tall)
    # Byte values represent vertical columns, bit 0 at top
    FONT = {
        # Characters extracted from "Badger" and "Magician" traces
        'B': [0x20, 0x4c, 0x3f, 0x24, 0x44, 0x24, 0x1b, 0x80, 0x00],
        'M': [0x3f, 0xc0, 0x3c, 0x03, 0xc0, 0x3c, 0x3f, 0xc0, 0x00],
        'a': [0x00, 0x08, 0x02, 0x05, 0x44, 0x05, 0x03, 0xc4, 0x00],
        'c': [0x00, 0x08, 0x03, 0x04, 0x44, 0x04, 0x06, 0x40, 0x00],
        'd': [0x00, 0x08, 0x03, 0x04, 0x44, 0x24, 0x3f, 0xc4, 0x00],
        'e': [0x00, 0x08, 0x03, 0x05, 0x44, 0x05, 0x03, 0x40, 0x00],
        'g': [0x00, 0x0e, 0x02, 0x05, 0x55, 0x05, 0x06, 0x52, 0x04],
        'i': [0x00, 0x04, 0x04, 0x27, 0xc4, 0x00, 0x00, 0x00, 0x00],
        'n': [0x04, 0x4c, 0x07, 0x04, 0x40, 0x04, 0x03, 0xc4, 0x00],
        'r': [0x04, 0x4c, 0x07, 0x02, 0x40, 0x04, 0x04, 0x00, 0x00],

        # Space
        ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],

        # Generate remaining characters using column-based approach
        # Uppercase (approximations based on the pattern style)
        'A': [0x00, 0x0c, 0x03, 0x04, 0x44, 0x04, 0x03, 0x0c, 0x00],
        'C': [0x00, 0x08, 0x02, 0x04, 0x44, 0x04, 0x02, 0x08, 0x00],
        'D': [0x00, 0x44, 0x3f, 0x04, 0x44, 0x04, 0x02, 0x08, 0x00],
        'E': [0x00, 0x44, 0x3f, 0x05, 0x44, 0x05, 0x04, 0x44, 0x00],
        'F': [0x00, 0x44, 0x3f, 0x05, 0x04, 0x05, 0x04, 0x04, 0x00],
        'G': [0x00, 0x08, 0x02, 0x04, 0x44, 0x24, 0x26, 0x08, 0x00],
        'H': [0x00, 0x44, 0x3f, 0x04, 0x00, 0x04, 0x3f, 0x44, 0x00],
        'I': [0x00, 0x00, 0x04, 0x44, 0x3f, 0x44, 0x04, 0x00, 0x00],
        'J': [0x00, 0x00, 0x00, 0x08, 0x44, 0x3f, 0x04, 0x00, 0x00],
        'K': [0x00, 0x44, 0x3f, 0x04, 0x08, 0x14, 0x22, 0x44, 0x00],
        'L': [0x00, 0x44, 0x3f, 0x44, 0x40, 0x40, 0x40, 0x40, 0x00],
        'N': [0x00, 0x44, 0x3f, 0x04, 0x08, 0x10, 0x3f, 0x44, 0x00],
        'O': [0x00, 0x08, 0x02, 0x04, 0x44, 0x04, 0x02, 0x08, 0x00],
        'P': [0x00, 0x44, 0x3f, 0x04, 0x04, 0x04, 0x02, 0x00, 0x00],
        'Q': [0x00, 0x08, 0x02, 0x04, 0x44, 0x24, 0x02, 0x48, 0x00],
        'R': [0x00, 0x44, 0x3f, 0x04, 0x04, 0x14, 0x22, 0x40, 0x00],
        'S': [0x00, 0x08, 0x02, 0x05, 0x44, 0x25, 0x06, 0x08, 0x00],
        'T': [0x00, 0x04, 0x04, 0x44, 0x3f, 0x44, 0x04, 0x04, 0x00],
        'U': [0x00, 0x04, 0x3f, 0x44, 0x40, 0x44, 0x3f, 0x04, 0x00],
        'V': [0x00, 0x04, 0x1c, 0x20, 0x40, 0x20, 0x1c, 0x04, 0x00],
        'W': [0x00, 0x1c, 0x20, 0x40, 0x30, 0x40, 0x20, 0x1c, 0x00],
        'X': [0x00, 0x44, 0x22, 0x08, 0x00, 0x08, 0x22, 0x44, 0x00],
        'Y': [0x00, 0x04, 0x02, 0x40, 0x38, 0x40, 0x02, 0x04, 0x00],
        'Z': [0x00, 0x44, 0x64, 0x54, 0x44, 0x4c, 0x44, 0x00, 0x00],

        # Lowercase (approximations)
        'b': [0x00, 0x04, 0x3f, 0xc4, 0x04, 0x44, 0x02, 0x08, 0x00],
        'f': [0x00, 0x04, 0x02, 0x45, 0x3f, 0x05, 0x04, 0x00, 0x00],
        'h': [0x00, 0x04, 0x3f, 0xc4, 0x04, 0x00, 0x04, 0xc0, 0x00],
        'j': [0x00, 0x00, 0x40, 0x44, 0x27, 0xc4, 0x00, 0x00, 0x00],
        'k': [0x00, 0x04, 0x3f, 0xc4, 0x10, 0x28, 0x44, 0x00, 0x00],
        'l': [0x00, 0x00, 0x04, 0x3f, 0xc4, 0x40, 0x00, 0x00, 0x00],
        'm': [0x00, 0x04, 0xc0, 0x04, 0xc0, 0x04, 0x03, 0xc4, 0x00],
        'o': [0x00, 0x08, 0x02, 0x04, 0x44, 0x04, 0x02, 0x08, 0x00],
        'p': [0x00, 0x04, 0xc7, 0xc4, 0x04, 0x04, 0x02, 0x00, 0x00],
        'q': [0x00, 0x00, 0x02, 0x04, 0x04, 0xc4, 0xc7, 0x04, 0x00],
        's': [0x00, 0x00, 0x02, 0x45, 0x44, 0x25, 0x08, 0x00, 0x00],
        't': [0x00, 0x04, 0x02, 0x3f, 0x44, 0x02, 0x00, 0x00, 0x00],
        'u': [0x00, 0x04, 0xc0, 0x40, 0x40, 0xc0, 0x04, 0x00, 0x00],
        'v': [0x00, 0x04, 0x18, 0x20, 0x40, 0x20, 0x18, 0x04, 0x00],
        'w': [0x00, 0x04, 0xc0, 0x30, 0x40, 0x30, 0xc0, 0x04, 0x00],
        'x': [0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00],
        'y': [0x00, 0x04, 0x18, 0x60, 0x40, 0x60, 0x18, 0x04, 0x00],
        'z': [0x00, 0x00, 0x44, 0x64, 0x54, 0x4c, 0x44, 0x00, 0x00],

        # Numbers
        '0': [0x00, 0x08, 0x02, 0x24, 0x44, 0x24, 0x02, 0x08, 0x00],
        '1': [0x00, 0x00, 0x04, 0x42, 0x3f, 0xc4, 0x40, 0x00, 0x00],
        '2': [0x00, 0x00, 0x42, 0x61, 0x50, 0x48, 0x46, 0x00, 0x00],
        '3': [0x00, 0x00, 0x02, 0x44, 0x44, 0x24, 0x1a, 0x00, 0x00],
        '4': [0x00, 0x10, 0x18, 0x14, 0x12, 0x3f, 0xd0, 0x10, 0x00],
        '5': [0x00, 0x00, 0x0e, 0x45, 0x44, 0x44, 0x38, 0x00, 0x00],
        '6': [0x00, 0x08, 0x12, 0x24, 0x44, 0x24, 0x18, 0x00, 0x00],
        '7': [0x00, 0x00, 0x04, 0x64, 0x14, 0x0c, 0x04, 0x00, 0x00],
        '8': [0x00, 0x00, 0x1a, 0x24, 0x44, 0x24, 0x1a, 0x00, 0x00],
        '9': [0x00, 0x00, 0x06, 0x09, 0x44, 0x29, 0x12, 0x04, 0x00],

        # Punctuation
        '!': [0x00, 0x00, 0x00, 0x5f, 0x40, 0x00, 0x00, 0x00, 0x00],
        '.': [0x00, 0x00, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00],
        ',': [0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00],
        '?': [0x00, 0x00, 0x02, 0x51, 0x04, 0x02, 0x00, 0x00, 0x00],
        '-': [0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00],
        ':': [0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00],
        "'": [0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],
    }

    ROWS_PER_CHAR = 9

    @staticmethod
    def _reverse_bits(byte: int) -> int:
        """Reverse the bit order in a byte (mirror horizontally)."""
        result = 0
        for i in range(8):
            if byte & (1 << i):
                result |= (1 << (7 - i))
        return result

    @staticmethod
    def render_text(text: str) -> bytes:
        """
        Render text to bitmap data for the badge display.

        The badge display uses 9 bytes per character, where each byte represents
        a vertical column of 8 pixels. Data is organized character-by-character.

        Args:
            text: Text string to render

        Returns:
            Bitmap data as bytes, suitable for upload to badge
        """
        result = bytearray()

        # Process each character - data is character-by-character
        for char in text:
            # Get character bitmap (9 columns per character)
            char_bitmap = TextRenderer.FONT.get(char, TextRenderer.FONT.get(' ', [0] * 9))

            # Add all 9 columns of this character (no bit reversal)
            for col_byte in char_bitmap:
                result.append(col_byte)

        return bytes(result)

    @staticmethod
    def get_text_width(text: str) -> int:
        """
        Get the width in pixels of the rendered text.

        Args:
            text: Text to measure

        Returns:
            Width in pixels (8 pixels per character)
        """
        return len(text) * 8

    @staticmethod
    def get_data_length(text: str) -> int:
        """
        Get the total byte length of rendered text.

        Args:
            text: Text to measure

        Returns:
            Total bytes (9 bytes per character)
        """
        return len(text) * TextRenderer.ROWS_PER_CHAR
